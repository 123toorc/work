https://zhuanlan.zhihu.com/p/26464793

中断系统是现代PC的基础架构之一，我们常常能听到很多相关概念：IRQ，PIRQ，PCI Interrupt PIN，MSI，GSI，Vector（中断向量）。这些术语有些是硬件概念，有些是软件概念，他们时常混在一起，让人十分迷惑。本系列希望能通过三篇文章来帮助大家厘清其中的关联和区别，它们分别是历史和原理篇（偏硬件）、软件篇（关于OS和BIOS如何设置和使用中断）和固件篇（BIOS如何根据硬件配置中断和向OS报告中断表）。
历史
当我们在操作电脑时，很多事情在同时发生，磁盘在飞速读写，网络在收发消息，而你也往往开了不少个任务在同时运行。这些能够发生，中断系统扮演了关键角色。在中断系统出现之前，人们（那时都是计算机专家）往往要等上一个任务结束才能进行下一个任务，这在今天是不能想象的。事实上中断系统出现的很早，Intel的传奇中断控制芯片8259在1976年就被用在8085系列产品中。PC在1981年出生时借鉴了这种思想，8259的升级版8259A被用于中断控制，而其统治PC长达近10年，直到486电脑的诞生！

1。PIC时代

PIC(Programmable Interrupt Controller)就是我们的8259A，让我们来瞻仰一下它的样子：




其中最重要的管脚是IR0~IR7，也就是能相应8个中断。后期由于中断不足，被扩展为级联的形式，如图：




分为主和从两块8259，这样我们就有了16 -1 = 15个中断源。8259一直工作的很好，中断如果还不够我们还可以通过中断共享或者再多级联几个8259，就可解决问题，直到多CPU的出现。这时候问题出现了，我们的主8259到底连接哪个CPU好呢？这是个大问题。

2。APIC来了

80486DX在1990年上市，其引入了SMP的概念，即多CPU（注意不是多核）。Intel为了适应SMP提出APIC（Advanced Programmable Interrupt Controller，高级中断控制器）的新技术。APIC 由两部分组成，一个称为LAPIC（Local APIC，本地高级中断控制器），一个称为IOAPIC（I/O APIC，I/O 高级中断控制器）。前者位于CPU中，在SMP 平台，每个CPU 都有一个自己的LAPIC（后期多核后，每个逻辑核都有个LAPIC）。后者通常位于外部设备芯片上，例如南桥上。像PIC 一样，连接各个产生中断的设备。而IOAPIC和LAPIC通过APIC Bus连接在一起。如图：




3。XAPIC，小小的改进

单独的3根线的APIC bus给系统设计带来了不少困扰，在奔腾4上其被取消而由系统总线代替，其他则区别不大，新的示意图如下：




系统中的IOAPIC可以有很多，在北桥被并入CPU中后，甚至CPU中也有IOAPIC（同时有LAPIC,感觉好方便）。这种架构极具伸缩性，被使用了很多年，直到核战争的爆发。

4。X2APIC

核战争，什么鬼？！其实是内核数目的战争。Intel和AMD不断的增加内核的数目，加上SMT（HT）技术，内核数目不断上升。在服务器上，至强CPU往往提供高达40到60个内核，如果是8路服务器，内核总数目可以高达60 × 8 = 480个！即使实际没有这么多内核，虚拟机技术的出现也往往成倍的需要虚拟内核。而唯一标识CPU内核身份的APIC ID在APIC寄存器中却只有8位（其细分为多个域，这里略过），也就是最多可以有255个内核(1个保留做广播用)。APIC不够用了！Intel大手一挥，推出了X2APIC，把APIC ID从8位扩展为32个bit，这下可以支持4G -1 （1个保留做广播用）个逻辑核，你们该满足了吧！顺便将原来略显怪异的MMIO访问方式变成MSR方式（后文详细介绍）。

我们现在的计算机几乎都是用APIC方式处理中断的，我们接下来看看他们是怎么工作的。

原理
CPU在运行目前任务时，当有特别事件发生时，CPU应当暂停正在执行的程序，转向执行处理该事件的子程序；事件处理完毕后，恢复原来的状态，再继续执行原来的程序。这种对这些事件的处理模式，称为程序中断（Interrupt）控制模式，简称中断控制或中断。这种处理紧急事件的服务子程序称为中断子程序。这种引起中断的事件称为中断源。这些事件包括磁盘、键盘等等输入输出设备，异常错误的发生甚至另一个CPU的调用。

1。PIC模式

在PIC时代，外部中断源都要连接到8259的IRQ引脚上，8259会通过INTR告诉CPU发生了中断。这时OS或者BIOS的中断控制程序会检查谁发生了中断，从而调用相应的中断相应历程。 其中的细节我们这里就不细述了，其过程大概分为以下几步：

1、一个或多个IR 引脚被触发中断（脉冲或者边缘），若对应的中断没有被屏蔽，8259 拉高INTR 管脚通知CPU 或上一级8259中断发生。

2、CPU 通过INTA 引脚响应8259，表示中断请求收到。8259则将IRR 中具有最高优先级位 清零，并设置ISR 中对应的位。在CPU发出中断查询脉冲后，8259将中断号提交到数据线上。

3、中断号对应的中断向量处理程序被调用，OS或者BIOS中断处理程序开始处理中断，完毕后写EOI并扫尾。

在这样一个周期完毕后，CPU继续处理之前的任务，像什么事也没有发生一样，一般用户甚至感受不到（实际上OS的中断处理例程有严格的时间要求，处理过长会触发watch dog 导致蓝屏）。

古老的PC留下了很多兼容性的问题，很多古老的设备占据了大量中断源，如图：




现在谁还有这么多串口并口呢，还有键盘和FDD？可是为了向前兼容，这些IRQ都被保留而不能做它用，甚至在APIC模式也是这样。向前兼容真是个沉重的包袱！

注意这里中断是有优先级的，IRQ数字越小优先级就越高。

2。APIC模式

如前所述，APIC 由两部分组成，一个称为LAPIC（Local APIC，本地高级中断控制器），一个称为IOAPIC（I/O APCI，I/O 高级中断控制器）。前者位于CPU中，在SMP 平台，每个内核都有一个自己的LAPIC。后者通常位于外部设备芯片上，例如南桥上。典型的连接关系如下图：




每个LAPIC都有自己唯一的APIC ID，每个IOAPIC也有自己唯一的ID。和PIC模式显著的区别是连接关系不再是硬件连线而是通过message。IOAPIC内部有个PRT（Programmable Redirection Table）表，里面的Destination Field标识了中断的目的地。在Physical模式下，含有目标APIC ID（Logical模式略）。在中断发生时，IOAPIC收到中断，会将中断转化为message放入系统总线，而CPU中只有APIC ID和Destination Field域中一致的LAPIC才会处理这条中断。用于处理来自IOAPIC 的中断消息的LAPIC内容就更多了，但最重要的寄存器还是IRR、ISR 以及EOI。其流程和PIC类似，这里就不在详述了。OS如何处理我们会在下一篇中介绍。

值得一提的是，为了保证向前兼容性，Intel在1997年发布的MultiProcessor Specification（MP spec）中要求APIC提供PIC兼容模式或Virtual Wire Mode（虚拟连线模式）。PIC模式如下图：




虚线代表了中断传递的过程，注意其中的IOAPIC被旁路了，而一个8259A的模拟硬件（通常是南桥芯片内置）则起到作用，它连接了CPU的INTR引脚。这样会对主板电路设计造成很多麻烦，而虚拟连线模式则更加常见，其如下图：


IOAPIC会将8259A模拟硬件的信号放入ICC Bus（后是系统总线），由LAPIC处理交给BSP，处理效果和原来一样而不要增加连线。

3。MSI

普通的PCI设备支持四个INTx，MSI（Message Signaled Interrupts）在1999年随着PCI 2.2规范被引入，在PCI 3.0中提出了MSI-X。MSI支持32个中断，而MSI-X将其扩展到了2048个。当一个PCI设备想发送中断时，它会向其PCI配置空间Capability结构中的Message Address的地址（通常是0xFEExxxxx）写Message Data数据，消息会被该设备连接的root complex转给LAPIC(多CPU时，有可能要通过QPI)，而不需要通过IOAPIC中转。Message Address中和IOAPIC类似，也有目标APIC ID，而message Data中同样有Vector的数目。这样从电气机械的角度，MSI减少了对interrupt pin个数的需求。从而使得连接变得更简单，而且据研究，其相比INTx,有时能提高1/3的效能。

微软在Vista后全面支持MSI和MSI-x，而Linux也早已经支持MSI。

其他
还有些杂项这里要特别说明一下

1。APIC ID

APIC ID并一定从0开始，数字也不一定连续，在任何地方的代码里都不能有这种假设。APIC ID可以被BIOS重置，但几乎没有BIOS这样做。

2。IOAPIC ID

随着北桥被移入了CPU ，一些北桥的除了内存控制器外其他的功能也被引入CPU。其中最重要的是PCIe的root complex和一个至少x16的root port用于连接显卡。如果CPU内置的显卡，也会连接到这个root port上，所以Intel平台除了在南桥外，在CPU内也有IOAPIC。在一个4路的志强服务器中就会有4 + 1 = 5个IOAPIC, 每个IOAPIC有24个入口，就可以支持24 * 5 = 120个中断入口。

3。LAPIC

除了IOAPIC能发送中断消息外，内核的LAPIC也可以通过发送IPI（Inter-Processor Interrupts）的方式发送中断给其他的内核。这种方式是OS和BIOS调度CPU内核的基本方式。


https://zhuanlan.zhihu.com/p/26524241

前文介绍了中断的硬件基础，今天我们深入了解一下中断的软件逻辑和不同操作系统的中断策略以及UEFI中的中断实现，最后我们澄清些常常混淆的概念。
中断处理流程
正如我们前文讲到的，中断处理在8086时代就已经引入PC。我们就从这个“远古”的鼻祖说起。

1。中断向量表

你有没有好奇过，0内存地址开始放了些什么东西呢？毕竟是最开始就要用的东西，一定非常重要！没错，那里就是中断向量表的家。在8086开始，中断向量表就占据这里，甚至在我们最新时髦的酷睿x代，它们还在这里。想不想看看这个顽固的家伙的样子？写个简单的 程序：

long *p = (long *) 0;
printf(“%x”, *p);
运行下看看。不出所料你的程序将产生一个异常，导致被强制关闭。还记得我们前面讲过地址转换，这个0地址是虚拟地址而不是物理地址，在保护模式下0的虚拟地址访问会产生一个异常，你是访问不到物理0地址的。我们在内核模式使用一些技巧或者我们进入实模式，我们才能看到它们。每个中断向量（vector）占据4个字节，Intel定义了256个向量，共用去1KB的内存空间。每个向量朴实无华，就是一个地址，指向该中断（INT）处理函数的入口，这也是它起名vector的原因。整个中断向量表就是一个大函数指针表，一个中断发生，CPU硬件就来这里查表，跳到相应地址就行了，好方便！实际情况稍微复杂点，CPU还要保护现场，将当前环境保存起来（一些寄存器和返回地址等压栈），以便处理完后返回现场继续执行。不过相对于我们接下来的保护模式的中断处理简单很多。没错，这个史前遗迹只在实模式发挥作用，我们只草草看看它的样子就行了：




这里主要是异常处理.


硬件中断向量一区。和我们上文的8259连接两相对照一下：




没错，这里就是主8259的IRQ的中断向量区。接下来就是BIOS保留区，作为介绍BIOS的专区，这里必须看一下：




PC传统Legacy BIOS的服务例程都在这里。看到它们不胜唏嘘，曾经INT 10H打字和INT 13H读写磁盘的美（YUAN）好（SHI）日子又浮现在眼前。。。不好，这是个暴露年龄的话题，后面我们就不讲了，下课。



开个玩笑，不过中断向量表今天也只在UEFI BIOS为了兼容传统OS启动的CSM模块中起作用，我们大致了解一下其中的原理即可。

2.中断描述符

在PC进入保护模式，一个复杂但有很多妙处的机制代替了中断向量表，它就是中断描述符表（IDT，interrupt Descriptor Table）。IDT将每个中断或者异常与它的服务例程连接起来。IDT不再固定放在某个位置，而是可以放在IDTR寄存器指向的任意内存(说是任意，也不能太随性，有些小要求，如8字节对齐等)，IDT的表项也从4个字节扩展到8个字节，大小也可以不满256，IDTR也指出了它的最大限制。如图：




IDT除了和中断向量一样指向一个例程地址之外，还包括其他一些信息：




其中的DPL（描述符特权级）与CS寄存器的CPL完成特权级的检查，可以避免低特权级的代码通过软件中断形式提权。它的运作形式和中断向量表类似，更多的是安全检查和可能的执行环境切换（例如ring 3 -> ring 0）。

3.中断和异常

ARM体系中断和异常是单独处理的，IRQ中断只是异常列表里的一项而已。X86中断和异常处理却混杂在一起，使用同一套机制，看似比较混乱。其实异常往往是处理器内部发生的，是同步的；而中断却是外部事件，是异步的。而它们的分布也是不同的，0到31号向量保留给异常，而更高的则往往是硬件中断和软件中断。异常分为三种：错误，陷阱和中止。这三种类型CPU对它们有不同的处理原则：错误往往是可以恢复的，错误修正后再执行刚才的错误就不会出问题了，改了就是好同志嘛！例如常用于内存管理的缺页异常，OS常常把内存换出到硬盘，它会在页表上动些手脚，CPU再次访问这块内存会发生异常，OS页面错误异常例程捕获到后赶紧把内存换回来，然后返回原处执行，就像没事发生一样。陷阱是留给软件挖坑的，CPU希望软件自己挖的坑自己能填上，它可以装作没看见，从下条继续。典型的例子是INT 3，我们的几乎所有调试工具（VS，windbg，甚至UEFI的source level debugger）都用它添加软件断点。中止就严重了，意味着发生硬件错误了，它往往能造成Windows蓝屏，linux panic等。异常一览表如下：




20到31被预留将来使用。硬件中断往往就从32开始。

4.中断优先级

PIC模式IRQ数目越低就意味着优先级越高。而在APIC模式下，IOAPIC连接的24个IRQ是平权的，先后并不关乎优先级高低。决定中断优先级的是它对应的中断向量的大小，X86体系有256个vector， 中断优先级的计算公式是：

优先级 = vector num / 16

即每16个中断一组，共享一个优先级，共16个。因为32以下vector被异常和保留占据，2到15是中断的优先级。数字越大越高优先级。中断优先级的控制是靠LAPIC的TPR（Task Priority Register，任务优先级寄存器）来控制的，它的结构如下：




TR只有4位标识可以接受的中断优先级，即16个。CPU内核只处理优先级比TR大的中断，也意味着TR每提高一个数字，就有16个中断被遮蔽！看来我们的中断要想被赶快处理，必须占个好位置。那么是不是IRQ数目越大，vector就越大呢？这是谁来决定的呢？这事可不由BIOS做主，OS是设置vector的主人。而不同的OS的处理也不近相同，我们具体看一下。

中断处理实践
Windows、Linux和BIOS在处理中断上有很多区别。我们从几个方面浮光掠影了解一二。

1. 中断向量设置

PIC如何设置中断向量已经过时，我们就不提了。这里只介绍APIC模式，如果你还记得上节关于IOAPIC的内容，其中最重要的PRT表，它由24个RTE（ RedirectionTableEntry）项组成，每一项对应一个IRQ引脚。它的内容除了上节介绍过的Destination Field之外，最低8位是该IRQ对应的vector，可以表示256个vector。OS根据自己的策略，为IRQ分配不同的vector。

Windows

Windows的HAL在设置vector时是根据系统枚举硬件时挨个设置的，因为先枚举的设备其IRQ的大小不确定，所以优先级并无一定之规。从vector不能推导IRQ，IRQ也不能推导vector，可以说全凭运气。为硬件IRQ分配的vector往往从0x31开始分配，应该是为了配合Windows的IRQL概念。大家可以在windbg里输入命令

!idt -a
查看一下自己机器的vector分配情况。这个IRQL比较让人混淆，实际上它并不是个硬件概念，和中断优先级并不同，它是微软定义的一套软件优先级方案。Windows用0到31来表示优先级，数值越大，优先级越高。如下图：




其中DPC/Dispatch是个分水岭，运行在这个优先级的线程不会被其他线程抢占。其上3到26是为了外围硬件保留的。最高的31显得很高大上，谁的地位这么高？你一定见过它，它就是在Windows蓝屏时的IRQL。HAL会把IRQL翻译到不同的硬件平台上，它和X86的中断优先级不是一个概念。

Linux

Linux没有IRQL的概念，他的vector就从0x20(32)开始分配，但是因为0x80(128)因为历史原因，被保留做系统调用（后改用sysenter指令，但为了兼容，还是保留），整个空间被一份为二。后面到0xee(238)为止。因为vector的大小关系到优先级，分配的时候为了保证对各个IOAPIC公平，分配的时候在各个IOAPIC间轮流分配。大家可以在shell里输入以下命令查看一下中断向量的分配情况：

cat /proc/interrupts
2. IRQ在多处理器的分发

还有个问题十分重要。某个vector由哪个CPU内核负责处理呢？Linux为了公平起见，并不会对BSP（bootstrap processor）另眼看待，所有内核一视同仁。Linux通过填写IOAPIC的RTE中的Delivery mode选择最低优先级策略，让TRP都被初始化做固定值，因此IRQ信号就可以公平的在CPU之间分发。感觉很民主有没有？（分分钟被Linus的独裁作风打脸）。有时为了优化性能，我们可以通过Linux的IRQ亲缘性来让特定内核为我们服务。我们可以通过命令

cat /proc/irq/xx/smp_affinity
查看xx IRQ由谁处理，如果是f的话代表是缺省策略，即大家都可以处理。我们可以通过下面命令分配个专有内核处理

echo 2 >/proc/irq/xx/smp_affinity
让APIC ID为2的内核处理。或者通过一些Irqbalance类似的工具来帮我们配置。

3.UEFI固件中的中断

UEFI固件内核中对异常和中断都有处理，还包含很多使用IPI调度内核的源程序，程序短小精干，包括大量注释。感兴趣的同学可以通过它学习中断处理和CPU内核调度。UEFI对中断的初始化和使用都在CPU的开发包里:

tianocore/edk2

有几个地方值得注意，我们来一一看看。

异常

UEFI内核对IDT的初始化程序在UefiCpuPkg的Library/CpuExceptionHandlerLib下。内核为所有的的中断和异常都分配了统一的入口CommonExceptionHandler。它对任何中断和异常没有任何特殊处理，如果没有人对该中断或异常做处理就会dump一些现在的CPU状态如APIC ID, 异常类型等，然后调用CpuDeadLoop陷入死循环，这也是UEFI工程师常见的画面。UEFI驱动可以在自己关心的异常中添加自己的处理函数，如支持通过串口和USB源程序级调试UEFI程序的Source Level Debugger就是个典型的例子，它Hook住了很多异常，用于调试和捕捉错误，它在：

tianocore/edk2

中断

UEFI的CSM模块还兼容以前BIOS使用的INT x软中断方式调用BIOS服务。随着UEFI的广泛推广和传统OS的渐渐淘汰，CSM也日薄西山，有些仅仅面向最新OS的项目都不含CSM的支持，所以关于它的内容这里略过。在保护模式下，UEFI内核仅仅对时钟中断进行了处理，并通过Timer Architectural Protocol开放出来供所有UEFI程序调用。也许你会好奇，那么多种USB设备和网卡等等的UEFI驱动难道不需要中断处理？是的，他们的中断在UEFI阶段都没有开启，他们的驱动通过Timer加Polling的方式来处理。举个例子，我们在UEFI Shell 下插入键盘，它能立刻起作用不是如在OS中USB控制器产生了中断。而是USB驱动注册了个Timer，过一会就Poll一下看看有没有新设备插入。就是这个Timer发现了新插入的键盘的。

这种仅仅依靠Timer的做法在OS阶段是行不通的，会带来严重的效能和功耗问题。但是在Boot阶段却问题不大，而且这样做保证了UEFI内核的简洁性。事实上，UEFI并不禁止驱动自己开启中断，但开启中断需要处理的中断共享、IOAPIC设置等等问题需要驱动自己解决，UEFI并不提供支持。

IPI

内核可以通过写自己LAPIC的ICR（Interrupt Command Register）发出IPI（(Inter-Processor Interrupt）调度别的内核完成任务，这也是任务调度的基本方法。事实上，因为APIC ID的不连续性，我们正是通过发送IPI的方法来统计内核的数量。BSP在启动时需要统计系统中可用的内核时，发送广播IPI，让大家都来报道，BSP开始点数，1，2，3。。。并一一记录在案。在启动OS前，通过ACPI table告诉OS有多少个内核。OS不应该自己统计内核数目，事实上固件可以通过瞒报内核的方式将部分内核挪作他用，但谁会这么做呢？

如何发起IPI在CPU package里有大量实例和库，大家可以参考。

其他
一些容易混淆的名词这里要特别说明一下

IRQ x:起源于PIC，指中断引脚，后在APIC时代沿用，泛指中断号。

Vector x/INT x: X是中断向量，如前文所说 IRQ不等于INT和vector.

PIRQ: PCI IRQ。它是描述南桥内部PCI设备的IRQ配置关系的。我们下一篇文章介绍。

GSI：Global System Interrupt，是ACPI spec规定的全局中断表。它为多IOAPIC情况下确定了系统唯一的一个中断号。例如IOAPIC1有24个IRQ，IOAPIC2也有24个IRQ，则IOAPIC2 的GSI是从24开始，GSI = 24 + IRQ（IOAPIC2）。

SCI：System Control Interrupt，系统控制中断，是ACPI定义的，专用于ACPI电源管理的一个IRQ。它在Intel平台上常常与南桥的电源管理模块一起，当外部EC等发生Event后会引发SCI。Windows的SCI ISR程序就是著名的acpi.sys。acpi.sys在收到SCI后会检查GPE状态寄存器以确定是谁引发的event，然后按照ACPI spec要求调用相应Method。详情请参照ACPI spec。可以认为SCI是ACPI定义的所有电源管理事件的总入口，它对应的IRQ在一般情况下是不能修改的。SCI是如何报告和简单的GPE method我们在下一篇中会详细介绍。

结语
说了这么多，如果我们从硬件和软件方面，梳理整个中断设置和处理的链条，会发现还有个环节没有解决。那就设备的IRQ是谁来决定的？是硬件hard wired?还是软件可以配置？OS是如何知道这些信息的呢？OS又是怎么知道IOAPIC的数目和位置的呢？这些都是UEFI固件需要解决的问题，我们在下一篇文章中会详细说明。在此之前，如以往一样，有几个思考问题可以让大家加深对中断和UEFI的理解：

1. 中断的引入，必然带来了代码重入的问题。我们知道，这可以通过设定优先级、信号量/临界区等等办法来解决。UEFI是通过什么方法呢？TPL和IRQL的相似和区别又是什么呢？

2. UEFI内核还不支持多线程，我们如果需要增加多线程调度，仅仅依靠时钟中断，够不够用呢？

3. OS利用缺页异常可以调度内存到硬盘上和实现Lazy loading等等实用的功能。UEFI的SMM内核也开启了缺页异常，但是却为了另外一个目的，你能看出是为了什么吗？

为什么叫vector呢？因为中断向量是个指针，指到ISR，而向量表是一大堆指针的集合。画到图上你就可以看出来和数学的vector比较类似。

其实中断在计算机学上分为vectored和non-vectored两种。向量式中断是指CPU通过某种方式可以得到一个vector，CPU就可以立刻找到中断服务程序。与之对应的non-vectored的是要通过polling的方式。很早之前的中断不少是Polling的方式知道谁在发送中断。vectored在当时是个新东西。

https://zhuanlan.zhihu.com/p/26647697

与简单定制的嵌入式系统不同，计算机是个开放的系统，大量的PCI设备带来了复杂的拓扑结构，PCI桥设备和扩展槽让固定的路由搭配成为了不可能。那么如何决定和设定中断以减少大量PCI设备中断共享，如何向OS报告这些中断设置信息呢？这些将是本文要重点讨论的内容。
PCI/PCIe设备构成了计算机的基础框架，本文的重点也将聚焦PCI设备的中断设置问题。在开始之前，我希望读者能阅读过前面几篇介绍PCI/PCIe和中断的文章，以便能有个共同的讨论基础。如果你还没有看过，下面是传输门：

深入PCI与PCIe之二：软件篇 - 知乎专栏

计算机中断体系一：历史和原理 - 知乎专栏

计算机中断体系二：中断处理 - 知乎专栏

PCI中断路由
前文我们介绍过了PIC和IOAPIC的中断引脚，那么PCI设备是如何连接到PIC/IOAPIC的中断引脚上呢?这个连接关系的原则是什么呢？

1。PCI设备中断

PCI spec为每个PCI设备定义了四个中断引脚，分别是INTA#，INTB#，INTC#和INTD#，如图：




如果PCI设备为单功能设备，则必须使用INTA#，对于多功能设备,各功能设备可任意接至PCI 总线的四条中断申请线INTA# - INTD# 。那么如何设定某个PCI设备的某个功能使用那个中断引脚呢？实际上这个是由PCI设备制造商决定的，并不能由主板固件后期更改。我们翻出PCI体系结构文中介绍的PCI配置空间，在其中interrupt pin会告知主板固件该func使用了哪个引脚，如图中红色圈标注：




一个PCI设备可以有8个func，而4个终端引脚意味着中断共享不可避免。PCI为了方便中断共享，定义中断是电平触发，低电平有效。中断信号与PCI CLK异步，设备一旦Assert为低，则要维持低电平状态，直到驱动程序清除这个中断请求。这样PCI中断可以为通过链的方式来共享，某个设备中断处理完毕后将其电平置高，只有该中断信号上所有的设备中断处理都结束了，该中断信号才能恢复高电平，整个中断处理才能结束。实际上中断共享不仅仅存在PCI设备各个func中，假设系统中有10个PCI设备，每个设备有4个中断引脚，要它们每个都独立意味着中断控制器需要有40个引脚。我们通过前文知道PIC只有15个引脚，IOAPIC通常有24个引脚，还有很多保留不可用，而一台计算机内部PCI设备往往超过20个。所以，中断更需要在设备之间共享。

让我们举个形象的比喻来理解中断共享的处理。想象操作系统中断处理调度器是个严厉的老师，设备中断处理例程是一群可爱的小朋友，他们被按照连接在PIC/IOAPIC引脚数分成若干排。每个小朋友手里都有个按钮，小朋友想要问问题，就按下按钮，老师回答完后他会再按一下恢复弹起状态。问题是老师是个近视眼，他看不见后面的小朋友。为了解决这个问题，在每排座位前面安装了个灯泡，当这排小朋友有人的按键被按下，灯就亮了。老师上课时，看见第2排灯亮了，他就停下来，问:“第2排第1个小朋友，是不是你要问问题？”得到肯定的答复就解答该小朋友，否定的话就问下一个，如此往复，直到该排没有人有问题，灯才灭，老师才能继续讲课。

看来在老师没有换个更好的眼镜或者做个近视矫正手术之前这是唯一的办法了。那么该如何为这些小朋友分组呢，老师把这个任务交给了班长小张。我们帮小张想想，怎么分配才能既公平又上课效率高呢？是不是平均分最好呢？假设小朋友都很乖，这样是最好的办法，但是小张知道班里有个话痨小朋友--小明，他什么都不懂但问题很多，他会频繁提问。假设他被分在第3排最后一个，老师每次看到第3排灯亮了，都从第一个小朋友问，经过了好久才问到小明，效率好低，小明每次很久才轮到他也很不满，上课节奏整体也被拖慢了!

怎么办？开除小明吗？可惜小明是校董的儿子，绝对不能少！让小明坐第一个位置吗？校规规定座位是流水席，每排都先来先坐，再说让小明又高问题又多，谁坐他后面别想问问题了，太不公平。看来只有给小明开小灶了，让他单独坐一排！

世界上没有绝对的公平，在资源捉襟见肘时会叫的孩子有奶吃在我们天朝还少吗？班长小张也只有做些妥协了。我们的计算机固件和主板硬件工程师在很多时候就扮演了左右为难的小张的角色，在硬件的限制下，尽量保证系统的响应时间。他们基于一些简单的原则：

A. 公平：尽量减少中断共享。

B. 效率：紧急或者频繁的设备可以独占中断

同时要充分理解PC系统中绝大多数设备都是单功能设备，所以仅使用INTA#信号，很少使用INTB#和INTC#信号，而INTD#信号更是极少使用。映射INTA#~INTD#到PIC/IOAPIC IRQ的机制称为“Swizzling”，它在不同情况下实现机制有很大不同，我们分别来看看。

2。PCI/PCIe扩展插槽

对主板上的PCI扩展插槽，用户插入什么设备，插在哪个槽内都不能在出厂时确定。我们这里要尽量考虑平衡原则和效率原则。我们将所有插槽的INTA#~INTD#分成四组串联起来如何？这样离得最近的Slot 1高兴了，每个都是我优先！万一有个用户把重要的网卡插在slot 4，效率会严重下降。在充分考虑到PCI设备绝大多数都是单功能设备（仅使用INTA#信号，很少使用INTB#和INTC#信号，而INTD#信号更是极少使用），PCI SIG推荐PCI to PCI bridge后slot连接关系应该组成如下图：




即Slot1 INTA#->Slot2 INT B#->Slot3 INTC#->Slot4 INTD#等等。这样，当然slot 1还是占些小便宜，但其他slot也有很大机会独占某个中断线(想想为什么)。这种Swizzling是主板设计硬件连线决定的，不由主板固件决定，但是主板固件需要了解这些信息。

PCI桥则将它下面的转换结果INTx转化为本身的INTx，接入芯片组内部的Swizzling。PCIe的插槽是1:1对应PCIe root port，PCIe root port可以看作PCI桥，等同处理。

3。芯片组内部

PCI SIG并没有规定芯片组内部Swizzling的规则，而芯片组内部设备在出厂时就已经确定了，芯片是不是可以hard code一个中断路由关系呢？实际上有些芯片组就是这么做的，在芯片硬件说明书中注明各种PCI设备INTx到IRQ的关系表，BIOS只要照着报告给OS就可以了。而Intel芯片组提供了更灵活的方式，BIOS可以根据需要设置中断路由，以适应不同的应用市场。不同的芯片组设置方法不同，有些给出了几组应用场景，BIOS可以根据需要选择一种，而在很早开始南桥芯片组ICH/PCH就给出了一种更灵活的方式，就是我们前文提到的PIRQ。简单来说就是在ICH/PCH内部加入了几个新的寄存器：IR寄存器组。IR寄存器组用于设定芯片组内部PCI设备中断INTA#-H# 连接到具体PIC/IOAPIC的哪个引脚上。这样BIOS就可以根据面向市场不同重新绘制中断路由图了，好方便！

OS接口
班长小张终于给小朋友排好了座位，他怎么把这些信息告诉各个老师呢？一个个告诉太麻烦，不如把所有情况打印成一张表贴子讲台上。我们的固件也是通过表告诉OS的，这里有两种表。

1。MP table

有感于DOS阶段中断设置的混乱，微软在推出Win95时联合Intel提出了PCI Interrupt Routing Table的数据结构，它的作用就是用来描述在使用8259中断控制器的系统下，PCI中断的路由关系。它和其他一些表构成了传统的MP table。它只在PIC模式下起作用，而PIC模式已经被淘汰，所以它的具体结构我们这里略过。这里要特别指出的是，固件在提交PIRQ table时要同步更新PCI配置空间的Interrupt line寄存器，如图篮圈部分：




2。ACPI table

在APIC模式下，固件应该通过ACPI的_PRT（PCI Routing Table） method返回主板上无论硬件还是固件设定的中断路由信息。ACPI spec有示例，但内容比较单薄。我们来看一个Intel开源硬件平台Minnowboard MAX固件是怎么处理的。源码在:

tianocore/edk2-platforms

_PRT代码如下：

   Method(_PRT,0)
    {
      If(PICM) {Return(AR00)} // APIC mode
      Return (PR00) // PIC Mode
    } // end _PRT
这里判断如果是PIC模式，返回PR00，如果是APIC模式返回AR00表。PR00和AR00其实是同一个中断路由关系的两个view，其实质内容是一致的。我们单看一下AR00就好：

 Name(AR00, Package()
  {
// SD Host #0 - eMMC
    Package() {0x0010FFFF, 0, 0, 16 },
// SD Host #1 - SDIO
    Package() {0x0011FFFF, 0, 0, 17 },
// SD Host #2 - SD Card
    Package() {0x0012FFFF, 0, 0, 18 },
// SATA Controller
    Package() {0x0013FFFF, 0, 0, 19 },
// xHCI Host
    Package() {0x0014FFFF, 0, 0, 20 },
// Low Power Audio Engine
    Package() {0x0015FFFF, 0, 0, 21 },
// USB OTG
    Package() {0x0016FFFF, 0, 0, 22 },
//
// MIPI-HSI
    Package() {0x0017FFFF, 0, 0, 23 },
//
// LPSS2 DMA
// LPSS2 I2C #4
    Package() {0x0018FFFF, 0, 0, 17 },
// LPSS2 I2C #1
// LPSS2 I2C #5
    Package() {0x0018FFFF, 2, 0, 19 },
// LPSS2 I2C #2
// LPSS2 I2C #6
    Package() {0x0018FFFF, 3, 0, 18 },
// LPSS2 I2C #3
// LPSS2 I2C #7
    Package() {0x0018FFFF, 1, 0, 16 },
 // SeC
    Package() {0x001AFFFF, 0, 0, 21 },
//
// High Definition Audio Controller
    Package() {0x001BFFFF, 0, 0, 22 },
//
// EHCI Controller
    Package() {0x001DFFFF, 0, 0, 23 },
// LPSS DMA
    Package() {0x001EFFFF, 0, 0, 19 },
// LPSS I2C #0
    Package() {0x001EFFFF, 3, 0, 16 },
// LPSS I2C #1
    Package() {0x001EFFFF, 1, 0, 17 },
// LPSS PCM
    Package() {0x001EFFFF, 2, 0, 18 },
// LPSS I2S
// LPSS HS-UART #0
// LPSS HS-UART #1
// LPSS SPI
// LPC Bridge
//
// SMBus Controller
    Package() {0x001FFFFF, 1, 0, 18 },
//
。。。。
}


这里的16，18，19..25就是上文介绍过的GSI(还记得GSI和IRQ的关系吗？)。通过这张大表，OS才能确定主板PCI设备和IRQ的连接关系。

其他中断信息
除了中断路由表之外，还有很多和中断相关的信息也需要通过ACPI向OS报告

1. LAPIC和IOAPIC

固件需要在ACPI的MADT表里向OS报告所有的LAPIC和IOAPIC。LAPIC默认映射到物理地是0xFEE00000（想想为什么不会互相冲突？），不需要报告，只要LAPIC ID即可。需要特别说明的是，因为APIC ID不一定从0开始，也不一定连续，所以其值要动态枚举而得。同时由于很多OS在调度processor时是挨个调度的，而HT的两个thread的APIC ID往往连续，同时被调度效能大大降低，Intel推荐HT的两个thread隔开报告。如果多个CPU socket，情况又有变化，这是系统调优的手段之一，这里不再赘述。

IOAPIC的地址和ID都由固件指定，必选准确的在MADT里向OS报告，每个IOAPIC的GSI偏移量也要报告。

2. SCI

在Intel的芯片组中，SCI通常缺省占用了中断9。它的值可以在芯片组的寄存器中修改，并需要通过FADT报告OS。因为这是个特殊指定的中断，所以在MADT中还要通过interrupt override节予以保留。

